#pragma once

// @generated by tools/codegen/gen.py from MetaFunctions.h

#include <ATen/TensorMeta.h>
#include <ATen/TensorIterator.h>

namespace at {

namespace meta {

struct TORCH_API acos : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API add_Tensor : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha);
};
struct TORCH_API addmv : public at::impl::MetaBase {
    void meta(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha);
};
struct TORCH_API acosh : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API asinh : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API atanh : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API asin : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API atan : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API bitwise_not : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API copysign_Tensor : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API ceil : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API cos : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API cosh : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API div_Tensor : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API div_Tensor_mode : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other, c10::optional<std::string> rounding_mode);
};
struct TORCH_API erf : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API erfc : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API exp : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API exp2 : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API expm1 : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API floor : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API frac : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API gcd : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API lcm : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API log : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API log10 : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API log1p : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API log2 : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API logaddexp : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API logaddexp2 : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API mul_Tensor : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API reciprocal : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API neg : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API round : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API rsqrt : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API silu : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API mish : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API sigmoid : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API sin : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API sinc : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API sinh : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API sqrt : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API tan : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API tanh : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API threshold : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value);
};
struct TORCH_API threshold_backward : public TensorIteratorBase {
    void meta(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold);
};
struct TORCH_API trunc : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API sub_Tensor : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha);
};
struct TORCH_API heaviside : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & values);
};
struct TORCH_API addmm : public at::impl::MetaBase {
    void meta(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha);
};
struct TORCH_API digamma : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API lgamma : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API polygamma : public TensorIteratorBase {
    void meta(int64_t n, const at::Tensor & self);
};
struct TORCH_API erfinv : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API i0 : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API sign : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API atan2 : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API hypot : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API igamma : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API igammac : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API nextafter : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API maximum : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API minimum : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API topk : public at::impl::MetaBase {
    void meta(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted);
};
struct TORCH_API pow_Tensor_Tensor : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & exponent);
};
struct TORCH_API pow_Scalar : public at::impl::MetaBase {
    void meta(const at::Scalar & self, const at::Tensor & exponent);
};
struct TORCH_API pow_Tensor_Scalar : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Scalar & exponent);
};
struct TORCH_API elu : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale);
};
struct TORCH_API hardsigmoid : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API leaky_relu : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Scalar & negative_slope);
};
struct TORCH_API softplus : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold);
};
struct TORCH_API softshrink : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Scalar & lambd);
};
struct TORCH_API adaptive_max_pool2d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size);
};
struct TORCH_API adaptive_max_pool2d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices);
};
struct TORCH_API adaptive_max_pool3d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size);
};
struct TORCH_API adaptive_max_pool3d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices);
};
struct TORCH_API fractional_max_pool2d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples);
};
struct TORCH_API max_pool2d_with_indices : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode);
};
struct TORCH_API max_pool2d_with_indices_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices);
};
struct TORCH_API reflection_pad1d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef padding);
};
struct TORCH_API replication_pad1d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef padding);
};
struct TORCH_API replication_pad1d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding);
};
struct TORCH_API replication_pad2d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef padding);
};
struct TORCH_API replication_pad3d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef padding);
};
struct TORCH_API upsample_linear1d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales);
};
struct TORCH_API upsample_linear1d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales);
};
struct TORCH_API upsample_bilinear2d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_bilinear2d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_bicubic2d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_bicubic2d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_trilinear3d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_trilinear3d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_nearest1d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales);
};
struct TORCH_API upsample_nearest1d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales);
};
struct TORCH_API upsample_nearest2d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_nearest2d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_nearest3d : public at::impl::MetaBase {
    void meta(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API upsample_nearest3d_backward : public at::impl::MetaBase {
    void meta(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w);
};
struct TORCH_API special_entr : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};
struct TORCH_API special_xlog1py : public TensorIteratorBase {
    void meta(const at::Tensor & self, const at::Tensor & other);
};
struct TORCH_API special_i0e : public TensorIteratorBase {
    void meta(const at::Tensor & self);
};

} // namespace meta
} // namespace at
