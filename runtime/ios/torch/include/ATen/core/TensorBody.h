#pragma once

#include <c10/core/Device.h>
#include <c10/core/Layout.h>
#include <c10/core/MemoryFormat.h>
#include <c10/core/QScheme.h>
#include <c10/core/Stream.h>
#include <c10/core/Scalar.h>
#include <c10/core/ScalarType.h>
#include <c10/core/ScalarTypeToTypeMeta.h>
#include <c10/core/Storage.h>
#include <ATen/core/TensorAccessor.h>
#include <c10/core/TensorImpl.h>
#include <c10/core/UndefinedTensorImpl.h>
#include <c10/core/WrapDimMinimal.h>
#include <c10/util/Exception.h>
#include <c10/util/Deprecated.h>
#include <c10/util/MaybeOwned.h>
#include <c10/util/Optional.h>
#include <c10/util/intrusive_ptr.h>
#include <ATen/core/DeprecatedTypePropertiesRegistry.h>
#include <ATen/core/DeprecatedTypeProperties.h>
#include <ATen/core/NamedTensor.h>
#include <ATen/core/QuantizerBase.h>
#include <torch/csrc/WindowsTorchApiMacro.h>

namespace caffe2 {
class Tensor;
}
namespace c10{
struct TensorOptions;
template<class T> class List;
}
namespace at {
struct Generator;
struct Type;
class DeprecatedTypeProperties;
class Tensor;
} // namespace at
namespace at {
namespace indexing {
struct TensorIndex;
} // namespace indexing
} // namespace at

namespace torch { namespace autograd {

struct Node;

}} // namespace torch::autograd

namespace at {

class Tensor;
using TensorList = ArrayRef<Tensor>;

using Stream = c10::Stream;

namespace impl {
inline bool variable_excluded_from_dispatch() {
#ifdef C10_MOBILE
  // Please read the comment in `VariableFallbackKernel.cpp` about the background of this change.
  return true;
#else
  TORCH_INTERNAL_ASSERT_DEBUG_ONLY(!c10::impl::tls_local_dispatch_key_set().excluded_.has(DispatchKey::Autograd));
  return c10::impl::tls_local_dispatch_key_set().excluded_.isSupersetOf(c10::autograd_dispatch_keyset);
#endif
}
}

// Tensor is a "generic" object holding a pointer to the underlying TensorImpl object, which
// has an embedded reference count. In this way, Tensor is similar to boost::intrusive_ptr.
//
// For example:
//
// void func(Tensor a) {
//   Tensor b = a;
//   ...
// }
//
// In this example, when we say Tensor b = a, we are creating a new object that points to the
// same underlying TensorImpl, and bumps its reference count. When b goes out of scope, the
// destructor decrements the reference count by calling release() on the TensorImpl it points to.
// The existing constructors, operator overloads, etc. take care to implement the correct semantics.
//
// Note that Tensor can also be NULL, i.e. it is not associated with any underlying TensorImpl, and
// special care must be taken to handle this.
class TORCH_API Tensor {
 private:
  struct unsafe_borrow_t { explicit unsafe_borrow_t() = default; };

  // Create a Tensor with a +0 reference count. Special care must be
  // taken to avoid decrementing this reference count at destruction
  // time. Intended to support MaybeOwnedTraits<Tensor>.
  explicit Tensor(unsafe_borrow_t, const Tensor& rhs)
      : impl_(c10::intrusive_ptr<at::TensorImpl, UndefinedTensorImpl>::reclaim(rhs.impl_.get())) {}
  friend MaybeOwnedTraits<Tensor>;

 public:
  Tensor(){};
  // This constructor should not be used by end users and is an implementation
  // detail invoked by autogenerated code.
  explicit Tensor(
      c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl> tensor_impl)
      : impl_(std::move(tensor_impl)) {
    if (impl_.get() == nullptr) {
      throw std::runtime_error("TensorImpl with nullptr is not supported");
    }
  }
  Tensor(const Tensor&) = default;
  Tensor(Tensor&&) = default;


 public:
  // Creates a new wrapper from TensorImpl. Intentionally a free method because
  // it should be used with care. Checks necessary invariants
  static Tensor wrap_tensor_impl(
      c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl> tensor_impl) {
    Tensor r(std::move(tensor_impl));
    r.enforce_invariants();
    return r;
  }

  int64_t dim() const {
    return impl_->dim();
  }
  int64_t storage_offset() const {
    return impl_->storage_offset();
  }

  Tensor contiguous(MemoryFormat memory_format=MemoryFormat::Contiguous) const {
    if (is_contiguous(memory_format)) {
      return *this;
    } else {
      return __dispatch_contiguous(memory_format);
    }
  }

  /// Should be used if *this can reasonably be expected to be contiguous and
  /// performance is important.
  /// Compared to contiguous, it saves a reference count
  /// increment/decrement if *this is already contiguous, at the cost
  /// in all cases of an extra pointer of stack usage, an extra branch
  /// to access, and an extra branch at destruction time.
  c10::MaybeOwned<Tensor> expect_contiguous(MemoryFormat memory_format=MemoryFormat::Contiguous) const &;

  // Use .contiguous() instead. Trying to borrow from a prvalue Tensor
  // will only lead to trouble and dangling references.
  c10::MaybeOwned<Tensor> expect_contiguous(MemoryFormat memory_format=MemoryFormat::Contiguous) && = delete;

  bool is_complex() const {
    return at::isComplexType(this->scalar_type());
  }

  bool is_floating_point() const {
    return at::isFloatingType(this->scalar_type());
  }

  bool is_signed() const {
    return at::isSignedType(this->scalar_type());
  }

  int64_t size(int64_t dim) const {
    // false is passed to maybe_wrap_dim so behavior is identical to array access (but with wrapping)
    dim = c10::maybe_wrap_dim(dim, this->dim(), false);
    return sizes()[dim];
  }

  int64_t stride(int64_t dim) const {
    // false is passed to maybe_wrap_dim so behavior is identical to array access (but with wrapping)
    dim = c10::maybe_wrap_dim(dim, this->dim(), false);
    return strides()[dim];
  }

  TensorImpl * unsafeGetTensorImpl() const {
    return impl_.get();
  }
  TensorImpl * unsafeReleaseTensorImpl() {
    return impl_.release();
  }
  const c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>& getIntrusivePtr() const {
    return impl_;
  }

  c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl> unsafeReleaseIntrusivePtr()  {
    return std::move(impl_);
  }

  bool defined() const {
    return impl_;
  }

  void reset() {
    impl_.reset();
  }

  // The following overloads are very intruiging.  Consider the following
  // program:
  //
  //    x[1] = 3;
  //
  // We would expect that the first entry of x is written to 3.  But how can we
  // actually achieve this?  x[1] evaluates to a tensor...
  //
  // The answer is, using a ref-qualifier.  x[1] is an rvalue, which cannot be
  // (profitably) assigned to in the traditional sense, so we overload
  // assignment to mean, "Actually, copy 3 into the tensor data."  This is done
  // with an rvalue-reference ref-qualified overload (the methods with && at the
  // end of their type.)
  //
  // There's one more fly in the ointment: We also want
  //
  //    Tensor x = y;
  //
  // to work, and we want it NOT to copy.  So we need a traditional operator=
  // overload.  But we MUST specify a mutable lvalue ref-qualifier, to
  // disambiguate the traditional overload from the rvalue-reference
  // ref-qualified overload.  Otherwise, it will be ambiguous, because
  // a non ref-qualified method is eligible for all situations.

  // Unfortunately, we have to write these constructors out manually
  // to work around an MSVC bug:
  //    error C2580: 'at::Tensor &at::Tensor::operator =(const at::Tensor &) &':
  //    multiple versions of a defaulted special member functions are not allowed
  // Tensor& operator=(const Tensor&) & = default;
  // Tensor& operator=(Tensor&&) & = default;

  // Also MSVC will wrongly issue the following warning with the aforementioned fix
  //    warning C4522: 'at::Tensor': multiple assignment operators specified
  // Let's just skip the warning.

  #ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning( disable : 4522 )
  #endif

  Tensor& operator=(const Tensor& x) & {
    impl_ = x.impl_;
    return *this;
  }
  Tensor& operator=(Tensor&& x) & {
    impl_ = std::move(x.impl_);
    return *this;
  }

  Tensor& operator=(Scalar v) &&;
  Tensor& operator=(const Tensor&) &&;
  Tensor& operator=(Tensor&&) &&;

  bool is_same(const Tensor& other) const noexcept {
    return impl_ == other.impl_;
  }
  size_t use_count() const noexcept {
    return impl_.use_count();
  }
  size_t weak_use_count() const noexcept {
    return impl_.weak_use_count();
  }

  std::string toString() const;

  IntArrayRef sizes() const {
    return impl_->sizes();
  }
  IntArrayRef strides() const {
    return impl_->strides();
  }
  // See impl::get_opt_names in ATen/NamedTensor.h for docs.
  c10::optional<DimnameList> opt_names() const {
    return impl::get_opt_names(unsafeGetTensorImpl());
  }
  // See impl::get_names in ATen/NamedTensor.h for docs.
  DimnameList names() const {
    return impl::get_names(unsafeGetTensorImpl());
  }
  int64_t ndimension() const {
    return dim();
  }

  bool is_contiguous(at::MemoryFormat memory_format=at::MemoryFormat::Contiguous) const {
    return impl_->is_contiguous(memory_format);
  }

  bool is_non_overlapping_and_dense() const {
    return impl_->is_non_overlapping_and_dense();
  }

  at::MemoryFormat suggest_memory_format(
      bool channels_last_strides_exact_match = false) const {
    // Setting channels_last_strides_exact_match to true forces function to
    // check 0,1 - sized dimension strides.
    if (!is_mkldnn() && !is_sparse()) {
      if (impl_->is_strides_like_channels_last()) {
        if (!channels_last_strides_exact_match ||
            get_channels_last_strides_2d(sizes()) == strides()) {
          return at::MemoryFormat::ChannelsLast;
        }
      }
      else if (impl_->is_strides_like_channels_last_3d()) {
        if (!channels_last_strides_exact_match ||
            get_channels_last_strides_3d(sizes()) == strides()) {
          return at::MemoryFormat::ChannelsLast3d;
        }
      }
    }
    return at::MemoryFormat::Contiguous;
  }

  // Total bytes consumed by the "view" of elements of the array.  Does not
  // include size of metadata.  The number reported here does not necessarily
  // correspond to the true physical memory consumed by a tensor; instead,
  // it reports the memory the tensor would take *if* it were contiguous.
  // Defined to be numel() * itemsize()
  size_t nbytes() const {
    TORCH_CHECK(layout () != at::kSparse,
                "nbytes is not defined for sparse tensors.  If you want the size of the constituent " \
                "tensors, add the nbytes of the indices and values.  If you want the size of the  " \
                "equivalent dense tensor, multiply numel() by element_size()");
    return impl_->numel() * impl_->itemsize();
  }

  int64_t numel() const {
    return impl_->numel();
  }

  // Length of one array element in bytes.  This is the traditional
  // Numpy naming.
  size_t itemsize() const {
    return impl_->itemsize();
  }

  // Same as itemsize().  This is the PyTorch naming.
  int64_t element_size() const {
    return static_cast<int64_t>(impl_->itemsize());
  }

  C10_DEPRECATED_MESSAGE("Tensor.type() is deprecated. Instead use Tensor.options(), which in many cases (e.g. in a constructor) is a drop-in replacement. If you were using data from type(), that is now available from Tensor itself, so instead of tensor.type().scalar_type(), use tensor.scalar_type() instead and instead of tensor.type().backend() use tensor.device().")
  DeprecatedTypeProperties & type() const {
    return globalDeprecatedTypePropertiesRegistry().getDeprecatedTypeProperties(
        dispatchKeyToBackend(legacyExtractDispatchKey(key_set())),
        scalar_type());
  }
  DispatchKeySet key_set() const {
    return impl_->key_set();
  }
  ScalarType scalar_type() const {
    return typeMetaToScalarType(impl_->dtype());
  }
  bool has_storage() const {
    return defined() && impl_->has_storage();
  }
  const Storage& storage() const {
    return impl_->storage();
  }
  bool is_alias_of(const at::Tensor& other) const{
    return impl_->storage().is_alias_of(other.storage());
  }
  Tensor toType(ScalarType t) const;
  Tensor toBackend(Backend b) const;

  C10_DEPRECATED_MESSAGE("Tensor.is_variable() is deprecated; everything is a variable now. (If you want to assert that variable has been appropriately handled already, use at::impl::variable_excluded_from_dispatch())")
  bool is_variable() const noexcept {
    return !at::impl::variable_excluded_from_dispatch();
  }

  /// Returns a `Tensor`'s layout.
  Layout layout() const noexcept {
    return impl_->layout();
  }

  /// Returns a `Tensor`'s dtype (`TypeMeta`).
  caffe2::TypeMeta dtype() const noexcept {
    return impl_->dtype();
  }

  /// Returns a `Tensor`'s device.
  inline Device device() const {
    return impl_->device();
  }

  /// Returns a `Tensor`'s device index.
  int64_t get_device() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->get_device();
  }


  /// Returns if a `Tensor` has CPU backend.
  bool is_cpu() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_cpu();
  }

  /// Returns if a `Tensor` has CUDA backend.
  bool is_cuda() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_cuda();
  }

  /// Returns if a `Tensor` has XPU backend.
  bool is_xpu() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_xpu();
  }

  /// Returns if a `Tensor` has XLA backend.
  bool is_xla() const {
    return impl_->is_xla();
  }

  /// Returns if a `Tensor` has HIP backend.
  bool is_hip() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_hip();
  }

  /// Returns if a `Tensor` has sparse backend.
  bool is_sparse() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_sparse();
  }

  /// Returns is a `Tensor` has a sparse CSR backend.
  bool is_sparse_csr() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_sparse_csr();
  }

  /// Returns if a `Tensor` is mkldnn tensor.
  bool is_mkldnn() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_mkldnn();
  }

  /// Returns if a `Tensor` is mlc tensor.
  bool is_mlc() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_mlc();
  }

  /// Returns if a `Tensor` is vulkan tensor.
  bool is_vulkan() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_vulkan();
  }

  /// Returns if a `Tensor` is metal tensor.
  bool is_metal() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_metal();
  }

  /// Returns if a `Tensor` has quantized backend.
  bool is_quantized() const {
    // NB: this is not a native function to avoid dispatching overhead.
    return impl_->is_quantized();
  }

  /// Returns if a `Tensor` is a meta tensor.  Meta tensors can
  /// also have other designations.
  bool is_meta() const {
    return impl_->is_meta();
  }

  /// If a tensor is a quantized tensor, returns its quantizer
  /// TODO: it's not in native_functions.yaml yet as it's not exposed to python
  QuantizerPtr quantizer() const;

  /// Returns if a `Tensor` has any dimension names
  bool has_names() const {
    // If a user is using unnamed tensors, then we can short-circuit right here.
    // Otherwise, impl::has_names attempts to retrieve names.
    if (!impl_->has_named_tensor_meta()) {
      return false;
    }
    return impl::has_names(unsafeGetTensorImpl());
  }

  /// Returns a `Tensor`'s dimension names data structure
  const NamedTensorMeta* get_named_tensor_meta() const {
    return static_cast<NamedTensorMeta*>(impl_->named_tensor_meta());
  }

  NamedTensorMeta* get_named_tensor_meta() {
    return static_cast<NamedTensorMeta*>(impl_->named_tensor_meta());
  }

  /// Returns the `TensorOptions` corresponding to this `Tensor`. Defined in
  /// TensorOptions.h.
  TensorOptions options() const;

  void* data_ptr() const {
    return this->unsafeGetTensorImpl()->data();
  }

  template <typename T>
  T * data_ptr() const;

  template<typename T>
  C10_DEPRECATED_MESSAGE("Tensor.data<T>() is deprecated. Please use Tensor.data_ptr<T>() instead.")
  T * data() const {
    return data_ptr<T>();
  }

  template <typename T>
  T item() const;

  // Purposely not defined here to avoid inlining
  void print() const;

  // Return a `TensorAccessor` for CPU `Tensor`s. You have to specify scalar type and
  // dimension.
  template<typename T, size_t N>
  TensorAccessor<T,N> accessor() const& {
    static_assert(N > 0, "accessor is used for indexing tensor, for scalars use *data_ptr<T>()");
    TORCH_CHECK(dim() == N, "TensorAccessor expected ", N, " dims but tensor has ", dim());
    return TensorAccessor<T,N>(data_ptr<T>(),sizes().data(),strides().data());
  }
  template<typename T, size_t N>
  TensorAccessor<T,N> accessor() && = delete;

  // Return a `GenericPackedTensorAccessor` for CUDA `Tensor`s. You have to specify scalar type and
  // dimension. You can optionally specify RestrictPtrTraits as a template parameter to
  // cast the data pointer to a __restrict__ pointer.
  // In order to use this, your CUDA kernel has to take a corresponding GenericPackedTensorAccessor
  // as an argument.
  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits, typename index_t = int64_t>
  GenericPackedTensorAccessor<T,N,PtrTraits,index_t> generic_packed_accessor() const& {
    static_assert(N > 0, "accessor is used for indexing tensor, for scalars use *data_ptr<T>()");
    TORCH_CHECK(dim() == N, "TensorAccessor expected ", N, " dims but tensor has ", dim());
    return GenericPackedTensorAccessor<T,N,PtrTraits,index_t>(static_cast<typename PtrTraits<T>::PtrType>(data_ptr<T>()),sizes().data(),strides().data());
  }
  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits, typename index_t = int64_t>
  GenericPackedTensorAccessor<T,N> generic_packed_accessor() && = delete;

  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits>
  PackedTensorAccessor32<T,N,PtrTraits> packed_accessor32() const& {
    return generic_packed_accessor<T,N,PtrTraits,int32_t>();
  }
  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits>
  PackedTensorAccessor32<T,N,PtrTraits> packed_accessor32() && = delete;

  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits>
  PackedTensorAccessor64<T,N,PtrTraits> packed_accessor64() const& {
    return generic_packed_accessor<T,N,PtrTraits,int64_t>();
  }
  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits>
  PackedTensorAccessor64<T,N,PtrTraits> packed_accessor64() && = delete;

  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits, typename index_t = int64_t>
  C10_DEPRECATED_MESSAGE("packed_accessor is deprecated, use packed_accessor32 or packed_accessor64 instead")
  GenericPackedTensorAccessor<T,N,PtrTraits,index_t> packed_accessor() const & {
    return generic_packed_accessor<T,N,PtrTraits,index_t>();
  }
  template<typename T, size_t N, template <typename U> class PtrTraits = DefaultPtrTraits, typename index_t = int64_t>
  C10_DEPRECATED_MESSAGE("packed_accessor is deprecated, use packed_accessor32 or packed_accessor64 instead")
  GenericPackedTensorAccessor<T,N,PtrTraits,index_t> packed_accessor() && = delete;

  Tensor operator~() const;
  Tensor operator-() const;
  Tensor& operator+=(const Tensor & other);
  Tensor& operator+=(Scalar other);
  Tensor& operator-=(const Tensor & other);
  Tensor& operator-=(Scalar other);
  Tensor& operator*=(const Tensor & other);
  Tensor& operator*=(Scalar other);
  Tensor& operator/=(const Tensor & other);
  Tensor& operator/=(Scalar other);
  Tensor& operator&=(const Tensor & other);
  Tensor& operator|=(const Tensor & other);
  Tensor& operator^=(const Tensor & other);
  Tensor operator[](Scalar index) const;
  Tensor operator[](Tensor index) const;
  Tensor operator[](int64_t index) const;

  Tensor index(ArrayRef<at::indexing::TensorIndex> indices) const;
  Tensor index(std::initializer_list<at::indexing::TensorIndex> indices) const;

  Tensor & index_put_(ArrayRef<at::indexing::TensorIndex> indices, Tensor const & rhs);
  Tensor & index_put_(ArrayRef<at::indexing::TensorIndex> indices, const Scalar& v);
  Tensor & index_put_(std::initializer_list<at::indexing::TensorIndex> indices, Tensor const & rhs);
  Tensor & index_put_(std::initializer_list<at::indexing::TensorIndex> indices, const Scalar& v);

  Tensor cpu() const;
  Tensor cuda() const;
  Tensor hip() const;
  Tensor vulkan() const;
  Tensor metal() const;

  // ~~~~~ Autograd API ~~~~~

  /// \fn bool is_leaf() const;
  ///
  /// All Tensors that have `requires_grad()` which is ``false`` will be leaf Tensors by convention.
  ///
  /// For Tensors that have `requires_grad()` which is ``true``, they will be leaf Tensors if they were
  /// created by the user. This means that they are not the result of an operation and so
  /// `grad_fn()` is `nullptr`.
  ///
  /// Only leaf Tensors will have their `grad()` populated during a call to `backward()`.
  /// To get `grad()` populated for non-leaf Tensors, you can use `retain_grad()`.
  ///
  /// Example:
  /// @code
  /// auto a = torch::rand(10, torch::requires_grad());
  /// std::cout << a.is_leaf() << std::endl; // prints `true`
  ///
  /// auto b = torch::rand(10, torch::requires_grad()).to(torch::kCUDA);
  /// std::cout << b.is_leaf() << std::endl; // prints `false`
  /// // b was created by the operation that cast a cpu Tensor into a cuda Tensor
  ///
  /// auto c = torch::rand(10, torch::requires_grad()) + 2;
  /// std::cout << c.is_leaf() << std::endl; // prints `false`
  /// // c was created by the addition operation
  ///
  /// auto d = torch::rand(10).cuda();
  /// std::cout << d.is_leaf() << std::endl; // prints `true`
  /// // d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)
  ///
  /// auto e = torch::rand(10).cuda().requires_grad_();
  /// std::cout << e.is_leaf() << std::endl; // prints `true`
  /// // e requires gradients and has no operations creating it
  ///
  /// auto f = torch::rand(10, torch::device(torch::kCUDA).requires_grad(true));
  /// std::cout << f.is_leaf() << std::endl; // prints `true`
  /// // f requires grad, has no operation creating it
  /// @endcode

  /// \fn void backward(const Tensor & gradient={}, c10::optional<bool> retain_graph=c10::nullopt, bool create_graph=false, c10::optional<TensorList> inputs=c10::nullopt) const;
  ///
  /// Computes the gradient of current tensor with respect to graph leaves.
  ///
  /// The graph is differentiated using the chain rule. If the tensor is
  /// non-scalar (i.e. its data has more than one element) and requires
  /// gradient, the function additionally requires specifying ``gradient``.
  /// It should be a tensor of matching type and location, that contains
  /// the gradient of the differentiated function w.r.t. this Tensor.
  ///
  /// This function accumulates gradients in the leaves - you might need to
  /// zero them before calling it.
  ///
  /// \param gradient Gradient w.r.t. the
  ///     tensor. If it is a tensor, it will be automatically converted
  ///     to a Tensor that does not require grad unless ``create_graph`` is True.
  ///     None values can be specified for scalar Tensors or ones that
  ///     don't require grad. If a None value would be acceptable then
  ///     this argument is optional.
  /// \param retain_graph If ``false``, the graph used to compute
  ///     the grads will be freed. Note that in nearly all cases setting
  ///     this option to True is not needed and often can be worked around
  ///     in a much more efficient way. Defaults to the value of
  ///     ``create_graph``.
  /// \param create_graph If ``true``, graph of the derivative will
  ///     be constructed, allowing to compute higher order derivative
  ///     products. Defaults to ``false``.
  /// \param inputs Inputs w.r.t. which the gradient will be accumulated into
  ///     ``at::Tensor::grad``. All other Tensors will be ignored. If not
  ///     provided, the gradient is accumulated into all the leaf Tensors
  ///     that were used to compute the current tensor. All the provided inputs
  ///     must be leaf Tensors.
  void backward(const Tensor & gradient={}, c10::optional<bool> retain_graph=c10::nullopt, bool create_graph=false, c10::optional<TensorList> inputs=c10::nullopt) const {
    // NB: Adding this wrapper to _backward here because we'd like our
    // 'backwards' api to accept the 'inputs' argument optionally. Since code gen
    // currently does not support optional of TensorList our approach is to replace
    // backward in native_functions.yaml with _backward and call it here instead.
    if (inputs.has_value()) {
      TORCH_CHECK(inputs.value().size() > 0, "'inputs' argument to backward cannot be empty")
      this->_backward(inputs.value(), gradient, retain_graph, create_graph);
    } else {
      this->_backward({}, gradient, retain_graph, create_graph);
    }
  }

  /// \fn Tensor detach() const;
  ///
  /// Returns a new Tensor, detached from the current graph.
  /// The result will never require gradient.

  /// \fn Tensor & detach_() const;
  ///
  /// Detaches the Tensor from the graph that created it, making it a leaf.
  /// Views cannot be detached in-place.

  /// \fn void retain_grad() const;
  ///
  /// Enables .grad() for non-leaf Tensors.

  const Tensor& set_requires_grad(bool requires_grad) const {
    impl_->set_requires_grad(requires_grad);
    return *this;
  }
  bool requires_grad() const {
    return impl_->requires_grad();
  }

  /// Return a mutable reference to the gradient. This is conventionally
  /// used as `t.grad() = x` to set a gradient to a completely new tensor.
  /// Note that this function work with a non-const Tensor and is not
  /// thread safe.
  Tensor& mutable_grad() const {
    return impl_->mutable_grad();
  }

  /// This function returns an undefined tensor by default and returns a defined tensor
  /// the first time a call to `backward()` computes gradients for this Tensor.
  /// The attribute will then contain the gradients computed and future calls
  /// to `backward()` will accumulate (add) gradients into it.
  const Tensor& grad() const {
    return impl_->grad();
  }

  // The Forward AD API functions below are low level and are not to be used by end
  // users who should use the API provided in torch/csrc/autograd.h

  /// This function returns the forward gradient for this Tensor at the given level.
  const Tensor& _fw_grad(uint64_t level) const {
    return impl_->_fw_grad(level, *this);
  }

  /// This function can be used to set the value of the forward grad.
  /// Note that the given new_grad might not be used directly if it has different
  /// metadata (size/stride/storage offset) compared to this Tensor. In that case,
  /// new_grad content will be copied into a new Tensor
  void _set_fw_grad(const Tensor& new_grad, uint64_t level, bool is_inplace_op) const {
    impl_->_set_fw_grad(new_grad, *this, level, is_inplace_op);
  }


  // STOP.  Thinking of adding a method here, which only makes use
  // of other ATen methods?  Define it in native_functions.yaml.

  //example
  //Tensor * add(Tensor & b);
  void __dispatch__backward(at::TensorList inputs, const c10::optional<at::Tensor> & gradient={}, c10::optional<bool> retain_graph=c10::nullopt, bool create_graph=false) const;
  void __dispatch_set_data(const at::Tensor & new_data) const;
  at::Tensor __dispatch_data() const;
  bool __dispatch_is_leaf() const;
  int64_t __dispatch_output_nr() const;
  int64_t __dispatch__version() const;
  at::Tensor & __dispatch_requires_grad_(bool requires_grad=true) const;
  void __dispatch_retain_grad() const;
  at::Tensor _fw_primal(int64_t level) const;
  at::Tensor & rename_(c10::optional<at::DimnameList> names) const;
  at::Tensor rename(c10::optional<at::DimnameList> names) const;
  at::Tensor align_to(at::DimnameList names) const;
  at::Tensor align_to(at::DimnameList order, int64_t ellipsis_idx) const;
  at::Tensor align_as(const at::Tensor & other) const;
  at::Tensor refine_names(at::DimnameList names) const;
  at::Tensor abs() const;
  at::Tensor & abs_() const;
  at::Tensor absolute() const;
  at::Tensor & absolute_() const;
  at::Tensor angle() const;
  at::Tensor sgn() const;
  at::Tensor & sgn_() const;
  at::Tensor conj() const;
  at::Tensor acos() const;
  at::Tensor & acos_() const;
  at::Tensor arccos() const;
  at::Tensor & arccos_() const;
  at::Tensor add(const at::Tensor & other, const at::Scalar & alpha=1) const;
  at::Tensor & add_(const at::Tensor & other, const at::Scalar & alpha=1) const;
  at::Tensor add(const at::Scalar & other, const at::Scalar & alpha=1) const;
  at::Tensor & add_(const at::Scalar & other, const at::Scalar & alpha=1) const;
  at::Tensor addmv(const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor & addmv_(const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor addr(const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor & addr_(const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor all(int64_t dim, bool keepdim=false) const;
  at::Tensor all(at::Dimname dim, bool keepdim=false) const;
  bool allclose(const at::Tensor & other, double rtol=1e-05, double atol=1e-08, bool equal_nan=false) const;
  at::Tensor any(int64_t dim, bool keepdim=false) const;
  at::Tensor any(at::Dimname dim, bool keepdim=false) const;
  at::Tensor argmax(c10::optional<int64_t> dim=c10::nullopt, bool keepdim=false) const;
  at::Tensor argmin(c10::optional<int64_t> dim=c10::nullopt, bool keepdim=false) const;
  at::Tensor acosh() const;
  at::Tensor & acosh_() const;
  at::Tensor arccosh() const;
  at::Tensor & arccosh_() const;
  at::Tensor asinh() const;
  at::Tensor & asinh_() const;
  at::Tensor arcsinh() const;
  at::Tensor & arcsinh_() const;
  at::Tensor atanh() const;
  at::Tensor & atanh_() const;
  at::Tensor arctanh() const;
  at::Tensor & arctanh_() const;
  at::Tensor as_strided(at::IntArrayRef size, at::IntArrayRef stride, c10::optional<int64_t> storage_offset=c10::nullopt) const;
  const at::Tensor & as_strided_(at::IntArrayRef size, at::IntArrayRef stride, c10::optional<int64_t> storage_offset=c10::nullopt) const;
  at::Tensor asin() const;
  at::Tensor & asin_() const;
  at::Tensor arcsin() const;
  at::Tensor & arcsin_() const;
  at::Tensor atan() const;
  at::Tensor & atan_() const;
  at::Tensor arctan() const;
  at::Tensor & arctan_() const;
  at::Tensor baddbmm(const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor & baddbmm_(const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor bernoulli(c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & bernoulli_(const at::Tensor & p, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & bernoulli_(double p=0.5, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor bernoulli(double p, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor bincount(const c10::optional<at::Tensor> & weights={}, int64_t minlength=0) const;
  at::Tensor bitwise_not() const;
  at::Tensor & bitwise_not_() const;
  at::Tensor copysign(const at::Tensor & other) const;
  at::Tensor & copysign_(const at::Tensor & other) const;
  at::Tensor copysign(const at::Scalar & other) const;
  at::Tensor & copysign_(const at::Scalar & other) const;
  at::Tensor logical_not() const;
  at::Tensor & logical_not_() const;
  at::Tensor logical_xor(const at::Tensor & other) const;
  at::Tensor & logical_xor_(const at::Tensor & other) const;
  at::Tensor logical_and(const at::Tensor & other) const;
  at::Tensor & logical_and_(const at::Tensor & other) const;
  at::Tensor logical_or(const at::Tensor & other) const;
  at::Tensor & logical_or_(const at::Tensor & other) const;
  at::Tensor bmm(const at::Tensor & mat2) const;
  at::Tensor broadcast_to(at::IntArrayRef size) const;
  at::Tensor ceil() const;
  at::Tensor & ceil_() const;
  std::vector<at::Tensor> unsafe_chunk(int64_t chunks, int64_t dim=0) const;
  std::vector<at::Tensor> chunk(int64_t chunks, int64_t dim=0) const;
  std::vector<at::Tensor> tensor_split(int64_t sections, int64_t dim=0) const;
  std::vector<at::Tensor> tensor_split(at::IntArrayRef indices, int64_t dim=0) const;
  std::vector<at::Tensor> tensor_split(const at::Tensor & tensor_indices_or_sections, int64_t dim=0) const;
  at::Tensor clamp(const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max=c10::nullopt) const;
  at::Tensor clamp(const c10::optional<at::Tensor> & min={}, const c10::optional<at::Tensor> & max={}) const;
  at::Tensor & clamp_(const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max=c10::nullopt) const;
  at::Tensor & clamp_(const c10::optional<at::Tensor> & min={}, const c10::optional<at::Tensor> & max={}) const;
  at::Tensor clamp_max(const at::Scalar & max) const;
  at::Tensor clamp_max(const at::Tensor & max) const;
  at::Tensor & clamp_max_(const at::Scalar & max) const;
  at::Tensor & clamp_max_(const at::Tensor & max) const;
  at::Tensor clamp_min(const at::Scalar & min) const;
  at::Tensor clamp_min(const at::Tensor & min) const;
  at::Tensor & clamp_min_(const at::Scalar & min) const;
  at::Tensor & clamp_min_(const at::Tensor & min) const;
  at::Tensor clip(const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max=c10::nullopt) const;
  at::Tensor clip(const c10::optional<at::Tensor> & min={}, const c10::optional<at::Tensor> & max={}) const;
  at::Tensor & clip_(const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max=c10::nullopt) const;
  at::Tensor & clip_(const c10::optional<at::Tensor> & min={}, const c10::optional<at::Tensor> & max={}) const;
  at::Tensor __dispatch_contiguous(at::MemoryFormat memory_format=MemoryFormat::Contiguous) const;
  at::Tensor & copy_(const at::Tensor & src, bool non_blocking=false) const;
  at::Tensor cos() const;
  at::Tensor & cos_() const;
  at::Tensor cosh() const;
  at::Tensor & cosh_() const;
  at::Tensor count_nonzero(at::IntArrayRef dim) const;
  at::Tensor count_nonzero(c10::optional<int64_t> dim=c10::nullopt) const;
  std::tuple<at::Tensor,at::Tensor> cummax(int64_t dim) const;
  std::tuple<at::Tensor,at::Tensor> cummax(at::Dimname dim) const;
  std::tuple<at::Tensor,at::Tensor> cummin(int64_t dim) const;
  std::tuple<at::Tensor,at::Tensor> cummin(at::Dimname dim) const;
  at::Tensor cumprod(int64_t dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor & cumprod_(int64_t dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor cumprod(at::Dimname dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor & cumprod_(at::Dimname dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor cumsum(int64_t dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor & cumsum_(int64_t dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor cumsum(at::Dimname dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor & cumsum_(at::Dimname dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor diag_embed(int64_t offset=0, int64_t dim1=-2, int64_t dim2=-1) const;
  at::Tensor diagflat(int64_t offset=0) const;
  at::Tensor diagonal(int64_t offset=0, int64_t dim1=0, int64_t dim2=1) const;
  at::Tensor diagonal(at::Dimname outdim, at::Dimname dim1, at::Dimname dim2, int64_t offset=0) const;
  at::Tensor & fill_diagonal_(const at::Scalar & fill_value, bool wrap=false) const;
  at::Tensor diff(int64_t n=1, int64_t dim=-1, const c10::optional<at::Tensor> & prepend={}, const c10::optional<at::Tensor> & append={}) const;
  at::Tensor div(const at::Tensor & other) const;
  at::Tensor & div_(const at::Tensor & other) const;
  at::Tensor div(const at::Tensor & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor & div_(const at::Tensor & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor div(const at::Scalar & other) const;
  at::Tensor & div_(const at::Scalar & other) const;
  at::Tensor div(const at::Scalar & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor & div_(const at::Scalar & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor divide(const at::Tensor & other) const;
  at::Tensor & divide_(const at::Tensor & other) const;
  at::Tensor divide(const at::Scalar & other) const;
  at::Tensor & divide_(const at::Scalar & other) const;
  at::Tensor divide(const at::Tensor & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor & divide_(const at::Tensor & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor divide(const at::Scalar & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor & divide_(const at::Scalar & other, c10::optional<std::string> rounding_mode) const;
  at::Tensor true_divide(const at::Tensor & other) const;
  at::Tensor & true_divide_(const at::Tensor & other) const;
  at::Tensor true_divide(const at::Scalar & other) const;
  at::Tensor & true_divide_(const at::Scalar & other) const;
  at::Tensor dot(const at::Tensor & tensor) const;
  at::Tensor vdot(const at::Tensor & other) const;
  at::Tensor new_empty(at::IntArrayRef size, at::TensorOptions options={}) const;
  at::Tensor new_empty(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) const;
  at::Tensor new_empty_strided(at::IntArrayRef size, at::IntArrayRef stride, at::TensorOptions options={}) const;
  at::Tensor new_empty_strided(at::IntArrayRef size, at::IntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) const;
  at::Tensor new_full(at::IntArrayRef size, const at::Scalar & fill_value, at::TensorOptions options={}) const;
  at::Tensor new_full(at::IntArrayRef size, const at::Scalar & fill_value, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) const;
  at::Tensor new_zeros(at::IntArrayRef size, at::TensorOptions options={}) const;
  at::Tensor new_zeros(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) const;
  const at::Tensor & resize_(at::IntArrayRef size, c10::optional<at::MemoryFormat> memory_format=c10::nullopt) const;
  at::Tensor erf() const;
  at::Tensor & erf_() const;
  at::Tensor erfc() const;
  at::Tensor & erfc_() const;
  at::Tensor exp() const;
  at::Tensor & exp_() const;
  at::Tensor exp2() const;
  at::Tensor & exp2_() const;
  at::Tensor expm1() const;
  at::Tensor & expm1_() const;
  at::Tensor expand(at::IntArrayRef size, bool implicit=false) const;
  at::Tensor expand_as(const at::Tensor & other) const;
  at::Tensor flatten(int64_t start_dim=0, int64_t end_dim=-1) const;
  at::Tensor flatten(int64_t start_dim, int64_t end_dim, at::Dimname out_dim) const;
  at::Tensor flatten(at::Dimname start_dim, at::Dimname end_dim, at::Dimname out_dim) const;
  at::Tensor flatten(at::DimnameList dims, at::Dimname out_dim) const;
  at::Tensor unflatten(int64_t dim, at::IntArrayRef sizes, c10::optional<at::DimnameList> names=c10::nullopt) const;
  at::Tensor unflatten(at::Dimname dim, at::IntArrayRef sizes, at::DimnameList names) const;
  at::Tensor & fill_(const at::Scalar & value) const;
  at::Tensor & fill_(const at::Tensor & value) const;
  at::Tensor floor() const;
  at::Tensor & floor_() const;
  at::Tensor floor_divide(const at::Tensor & other) const;
  at::Tensor & floor_divide_(const at::Tensor & other) const;
  at::Tensor floor_divide(const at::Scalar & other) const;
  at::Tensor & floor_divide_(const at::Scalar & other) const;
  at::Tensor frac() const;
  at::Tensor & frac_() const;
  at::Tensor gcd(const at::Tensor & other) const;
  at::Tensor & gcd_(const at::Tensor & other) const;
  at::Tensor lcm(const at::Tensor & other) const;
  at::Tensor & lcm_(const at::Tensor & other) const;
  at::Tensor index(const c10::List<c10::optional<at::Tensor>> & indices) const;
  at::Tensor & index_copy_(int64_t dim, const at::Tensor & index, const at::Tensor & source) const;
  at::Tensor index_copy(int64_t dim, const at::Tensor & index, const at::Tensor & source) const;
  at::Tensor & index_copy_(at::Dimname dim, const at::Tensor & index, const at::Tensor & source) const;
  at::Tensor index_copy(at::Dimname dim, const at::Tensor & index, const at::Tensor & source) const;
  at::Tensor & index_put_(const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate=false) const;
  at::Tensor index_put(const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate=false) const;
  at::Tensor inverse() const;
  at::Tensor isclose(const at::Tensor & other, double rtol=1e-05, double atol=1e-08, bool equal_nan=false) const;
  at::Tensor isnan() const;
  bool is_distributed() const;
  bool __dispatch_is_floating_point() const;
  bool __dispatch_is_complex() const;
  at::Tensor isreal() const;
  bool is_nonzero() const;
  bool is_same_size(const at::Tensor & other) const;
  bool __dispatch_is_signed() const;
  at::Tensor kron(const at::Tensor & other) const;
  std::tuple<at::Tensor,at::Tensor> kthvalue(int64_t k, int64_t dim=-1, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> kthvalue(int64_t k, at::Dimname dim, bool keepdim=false) const;
  at::Tensor nan_to_num(c10::optional<double> nan=c10::nullopt, c10::optional<double> posinf=c10::nullopt, c10::optional<double> neginf=c10::nullopt) const;
  at::Tensor & nan_to_num_(c10::optional<double> nan=c10::nullopt, c10::optional<double> posinf=c10::nullopt, c10::optional<double> neginf=c10::nullopt) const;
  at::Tensor ldexp(const at::Tensor & other) const;
  at::Tensor & ldexp_(const at::Tensor & other) const;
  at::Tensor log() const;
  at::Tensor & log_() const;
  at::Tensor log10() const;
  at::Tensor & log10_() const;
  at::Tensor log1p() const;
  at::Tensor & log1p_() const;
  at::Tensor log2() const;
  at::Tensor & log2_() const;
  at::Tensor logaddexp(const at::Tensor & other) const;
  at::Tensor logaddexp2(const at::Tensor & other) const;
  at::Tensor xlogy(const at::Tensor & other) const;
  at::Tensor xlogy(const at::Scalar & other) const;
  at::Tensor & xlogy_(const at::Tensor & other) const;
  at::Tensor & xlogy_(const at::Scalar & other) const;
  at::Tensor logdet() const;
  at::Tensor log_softmax(int64_t dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor log_softmax(at::Dimname dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor logcumsumexp(int64_t dim) const;
  at::Tensor logcumsumexp(at::Dimname dim) const;
  at::Tensor logsumexp(at::IntArrayRef dim, bool keepdim=false) const;
  at::Tensor logsumexp(at::DimnameList dim, bool keepdim=false) const;
  at::Tensor matmul(const at::Tensor & other) const;
  at::Tensor matrix_power(int64_t n) const;
  at::Tensor matrix_exp() const;
  std::tuple<at::Tensor,at::Tensor> max(int64_t dim, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> max(at::Dimname dim, bool keepdim=false) const;
  at::Tensor amax(at::IntArrayRef dim={}, bool keepdim=false) const;
  at::Tensor mean(c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor mean(at::IntArrayRef dim, bool keepdim=false, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor mean(at::DimnameList dim, bool keepdim=false, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor median() const;
  std::tuple<at::Tensor,at::Tensor> median(int64_t dim, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> median(at::Dimname dim, bool keepdim=false) const;
  at::Tensor nanmedian() const;
  std::tuple<at::Tensor,at::Tensor> nanmedian(int64_t dim, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> nanmedian(at::Dimname dim, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> min(int64_t dim, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> min(at::Dimname dim, bool keepdim=false) const;
  at::Tensor amin(at::IntArrayRef dim={}, bool keepdim=false) const;
  at::Tensor mm(const at::Tensor & mat2) const;
  std::tuple<at::Tensor,at::Tensor> mode(int64_t dim=-1, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> mode(at::Dimname dim, bool keepdim=false) const;
  at::Tensor mul(const at::Tensor & other) const;
  at::Tensor & mul_(const at::Tensor & other) const;
  at::Tensor mul(const at::Scalar & other) const;
  at::Tensor & mul_(const at::Scalar & other) const;
  at::Tensor multiply(const at::Tensor & other) const;
  at::Tensor & multiply_(const at::Tensor & other) const;
  at::Tensor multiply(const at::Scalar & other) const;
  at::Tensor & multiply_(const at::Scalar & other) const;
  at::Tensor mv(const at::Tensor & vec) const;
  at::Tensor mvlgamma(int64_t p) const;
  at::Tensor & mvlgamma_(int64_t p) const;
  at::Tensor narrow_copy(int64_t dim, int64_t start, int64_t length) const;
  at::Tensor narrow(int64_t dim, int64_t start, int64_t length) const;
  at::Tensor narrow(int64_t dim, const at::Tensor & start, int64_t length) const;
  at::Tensor permute(at::IntArrayRef dims) const;
  at::Tensor movedim(at::IntArrayRef source, at::IntArrayRef destination) const;
  at::Tensor movedim(int64_t source, int64_t destination) const;
  at::Tensor moveaxis(at::IntArrayRef source, at::IntArrayRef destination) const;
  at::Tensor moveaxis(int64_t source, int64_t destination) const;
  at::Tensor numpy_T() const;
  bool is_pinned() const;
  at::Tensor pin_memory() const;
  at::Tensor pinverse(double rcond=1e-15) const;
  at::Tensor rad2deg() const;
  at::Tensor & rad2deg_() const;
  at::Tensor deg2rad() const;
  at::Tensor & deg2rad_() const;
  at::Tensor ravel() const;
  at::Tensor reciprocal() const;
  at::Tensor & reciprocal_() const;
  at::Tensor neg() const;
  at::Tensor & neg_() const;
  at::Tensor negative() const;
  at::Tensor & negative_() const;
  at::Tensor repeat(at::IntArrayRef repeats) const;
  at::Tensor repeat_interleave(const at::Tensor & repeats, c10::optional<int64_t> dim=c10::nullopt) const;
  at::Tensor repeat_interleave(int64_t repeats, c10::optional<int64_t> dim=c10::nullopt) const;
  at::Tensor reshape(at::IntArrayRef shape) const;
  at::Tensor reshape_as(const at::Tensor & other) const;
  at::Tensor round() const;
  at::Tensor & round_() const;
  at::Tensor relu() const;
  at::Tensor & relu_() const;
  at::Tensor prelu(const at::Tensor & weight) const;
  std::tuple<at::Tensor,at::Tensor> prelu_backward(const at::Tensor & grad_output, const at::Tensor & weight) const;
  at::Tensor hardshrink(const at::Scalar & lambd=0.5) const;
  at::Tensor hardshrink_backward(const at::Tensor & grad_out, const at::Scalar & lambd) const;
  at::Tensor rsqrt() const;
  at::Tensor & rsqrt_() const;
  at::Tensor select(at::Dimname dim, int64_t index) const;
  at::Tensor select(int64_t dim, int64_t index) const;
  at::Tensor sigmoid() const;
  at::Tensor & sigmoid_() const;
  at::Tensor logit(c10::optional<double> eps=c10::nullopt) const;
  at::Tensor & logit_(c10::optional<double> eps=c10::nullopt) const;
  at::Tensor sin() const;
  at::Tensor & sin_() const;
  at::Tensor sinc() const;
  at::Tensor & sinc_() const;
  at::Tensor sinh() const;
  at::Tensor & sinh_() const;
  at::Tensor detach() const;
  at::Tensor & detach_() const;
  int64_t size(at::Dimname dim) const;
  at::Tensor slice(int64_t dim=0, c10::optional<int64_t> start=c10::nullopt, c10::optional<int64_t> end=c10::nullopt, int64_t step=1) const;
  std::tuple<at::Tensor,at::Tensor> slogdet() const;
  at::Tensor smm(const at::Tensor & mat2) const;
  at::Tensor softmax(int64_t dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor softmax(at::Dimname dim, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  std::vector<at::Tensor> unsafe_split(int64_t split_size, int64_t dim=0) const;
  std::vector<at::Tensor> split(int64_t split_size, int64_t dim=0) const;
  std::vector<at::Tensor> unsafe_split_with_sizes(at::IntArrayRef split_sizes, int64_t dim=0) const;
  std::vector<at::Tensor> split_with_sizes(at::IntArrayRef split_sizes, int64_t dim=0) const;
  std::vector<at::Tensor> hsplit(int64_t sections) const;
  std::vector<at::Tensor> hsplit(at::IntArrayRef indices) const;
  std::vector<at::Tensor> vsplit(int64_t sections) const;
  std::vector<at::Tensor> vsplit(at::IntArrayRef indices) const;
  std::vector<at::Tensor> dsplit(int64_t sections) const;
  std::vector<at::Tensor> dsplit(at::IntArrayRef indices) const;
  at::Tensor squeeze() const;
  at::Tensor squeeze(int64_t dim) const;
  at::Tensor squeeze(at::Dimname dim) const;
  at::Tensor & squeeze_() const;
  at::Tensor & squeeze_(int64_t dim) const;
  at::Tensor & squeeze_(at::Dimname dim) const;
  at::Tensor sspaddmm(const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor stft(int64_t n_fft, c10::optional<int64_t> hop_length=c10::nullopt, c10::optional<int64_t> win_length=c10::nullopt, const c10::optional<at::Tensor> & window={}, bool normalized=false, c10::optional<bool> onesided=c10::nullopt, c10::optional<bool> return_complex=c10::nullopt) const;
  at::Tensor istft(int64_t n_fft, c10::optional<int64_t> hop_length=c10::nullopt, c10::optional<int64_t> win_length=c10::nullopt, const c10::optional<at::Tensor> & window={}, bool center=true, bool normalized=false, c10::optional<bool> onesided=c10::nullopt, c10::optional<int64_t> length=c10::nullopt, bool return_complex=false) const;
  int64_t stride(at::Dimname dim) const;
  at::Tensor sum(c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor sum(at::IntArrayRef dim, bool keepdim=false, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor sum(at::DimnameList dim, bool keepdim=false, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor nansum(c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor nansum(at::IntArrayRef dim, bool keepdim=false, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor sum_to_size(at::IntArrayRef size) const;
  at::Tensor sqrt() const;
  at::Tensor & sqrt_() const;
  at::Tensor square() const;
  at::Tensor & square_() const;
  at::Tensor std(bool unbiased=true) const;
  at::Tensor std(at::IntArrayRef dim, bool unbiased=true, bool keepdim=false) const;
  at::Tensor std(c10::optional<at::IntArrayRef> dim, c10::optional<int64_t> correction, bool keepdim=false) const;
  at::Tensor std(at::DimnameList dim, bool unbiased=true, bool keepdim=false) const;
  at::Tensor std(at::DimnameList dim, c10::optional<int64_t> correction, bool keepdim=false) const;
  at::Tensor prod(c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor prod(int64_t dim, bool keepdim=false, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor prod(at::Dimname dim, bool keepdim=false, c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor t() const;
  at::Tensor & t_() const;
  at::Tensor tan() const;
  at::Tensor & tan_() const;
  at::Tensor tanh() const;
  at::Tensor & tanh_() const;
  at::Tensor tile(at::IntArrayRef dims) const;
  at::Tensor transpose(int64_t dim0, int64_t dim1) const;
  at::Tensor transpose(at::Dimname dim0, at::Dimname dim1) const;
  at::Tensor & transpose_(int64_t dim0, int64_t dim1) const;
  at::Tensor flip(at::IntArrayRef dims) const;
  at::Tensor fliplr() const;
  at::Tensor flipud() const;
  at::Tensor roll(at::IntArrayRef shifts, at::IntArrayRef dims={}) const;
  at::Tensor rot90(int64_t k=1, at::IntArrayRef dims={0,1}) const;
  at::Tensor trunc() const;
  at::Tensor & trunc_() const;
  at::Tensor fix() const;
  at::Tensor & fix_() const;
  at::Tensor type_as(const at::Tensor & other) const;
  at::Tensor unsqueeze(int64_t dim) const;
  at::Tensor & unsqueeze_(int64_t dim) const;
  at::Tensor var(bool unbiased=true) const;
  at::Tensor var(at::IntArrayRef dim, bool unbiased=true, bool keepdim=false) const;
  at::Tensor var(c10::optional<at::IntArrayRef> dim, c10::optional<int64_t> correction, bool keepdim=false) const;
  at::Tensor var(at::DimnameList dim, bool unbiased=true, bool keepdim=false) const;
  at::Tensor var(at::DimnameList dim, c10::optional<int64_t> correction, bool keepdim=false) const;
  at::Tensor view_as(const at::Tensor & other) const;
  at::Tensor where(const at::Tensor & condition, const at::Tensor & other) const;
  at::Tensor norm(const c10::optional<at::Scalar> & p, at::ScalarType dtype) const;
  at::Tensor norm(const at::Scalar & p=2) const;
  at::Tensor norm(const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) const;
  at::Tensor norm(const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim=false) const;
  at::Tensor norm(const c10::optional<at::Scalar> & p, at::DimnameList dim, bool keepdim, at::ScalarType dtype) const;
  at::Tensor norm(const c10::optional<at::Scalar> & p, at::DimnameList dim, bool keepdim=false) const;
  std::tuple<at::Tensor,at::Tensor> frexp() const;
  at::Tensor clone(c10::optional<at::MemoryFormat> memory_format=c10::nullopt) const;
  at::Tensor positive() const;
  const at::Tensor & resize_as_(const at::Tensor & the_template, c10::optional<at::MemoryFormat> memory_format=c10::nullopt) const;
  at::Tensor & zero_() const;
  at::Tensor sub(const at::Tensor & other, const at::Scalar & alpha=1) const;
  at::Tensor & sub_(const at::Tensor & other, const at::Scalar & alpha=1) const;
  at::Tensor sub(const at::Scalar & other, const at::Scalar & alpha=1) const;
  at::Tensor & sub_(const at::Scalar & other, const at::Scalar & alpha=1) const;
  at::Tensor subtract(const at::Tensor & other, const at::Scalar & alpha=1) const;
  at::Tensor & subtract_(const at::Tensor & other, const at::Scalar & alpha=1) const;
  at::Tensor subtract(const at::Scalar & other, const at::Scalar & alpha=1) const;
  at::Tensor & subtract_(const at::Scalar & other, const at::Scalar & alpha=1) const;
  at::Tensor heaviside(const at::Tensor & values) const;
  at::Tensor & heaviside_(const at::Tensor & values) const;
  at::Tensor addmm(const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor & addmm_(const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  const at::Tensor & sparse_resize_(at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) const;
  const at::Tensor & sparse_resize_and_clear_(at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) const;
  at::Tensor sparse_mask(const at::Tensor & mask) const;
  at::Tensor to_dense(c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  int64_t sparse_dim() const;
  int64_t _dimI() const;
  int64_t dense_dim() const;
  int64_t _dimV() const;
  int64_t _nnz() const;
  at::Tensor coalesce() const;
  bool is_coalesced() const;
  at::Tensor _indices() const;
  at::Tensor _values() const;
  at::Tensor & _coalesced_(bool coalesced) const;
  at::Tensor indices() const;
  at::Tensor values() const;
  at::Tensor crow_indices() const;
  at::Tensor col_indices() const;
  std::vector<at::Tensor> unbind(int64_t dim=0) const;
  std::vector<at::Tensor> unbind(at::Dimname dim) const;
  at::Tensor to_sparse(int64_t sparse_dim) const;
  at::Tensor to_sparse() const;
  at::Tensor to_mkldnn(c10::optional<at::ScalarType> dtype=c10::nullopt) const;
  at::Tensor dequantize() const;
  double q_scale() const;
  int64_t q_zero_point() const;
  at::Tensor q_per_channel_scales() const;
  at::Tensor q_per_channel_zero_points() const;
  int64_t q_per_channel_axis() const;
  at::Tensor int_repr() const;
  at::QScheme qscheme() const;
  at::Tensor to(at::TensorOptions options={}, bool non_blocking=false, bool copy=false, c10::optional<at::MemoryFormat> memory_format=c10::nullopt) const;
  at::Tensor to(c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, bool non_blocking, bool copy, c10::optional<at::MemoryFormat> memory_format) const;
  at::Tensor to(at::Device device, at::ScalarType dtype, bool non_blocking=false, bool copy=false, c10::optional<at::MemoryFormat> memory_format=c10::nullopt) const;
  at::Tensor to(at::ScalarType dtype, bool non_blocking=false, bool copy=false, c10::optional<at::MemoryFormat> memory_format=c10::nullopt) const;
  at::Tensor to(const at::Tensor & other, bool non_blocking=false, bool copy=false, c10::optional<at::MemoryFormat> memory_format=c10::nullopt) const;
  at::Scalar item() const;
  at::Tensor & set_(at::Storage source) const;
  at::Tensor & set_(at::Storage source, int64_t storage_offset, at::IntArrayRef size, at::IntArrayRef stride={}) const;
  at::Tensor & set_(const at::Tensor & source) const;
  at::Tensor & set_() const;
  bool is_set_to(const at::Tensor & tensor) const;
  at::Tensor & masked_fill_(const at::Tensor & mask, const at::Scalar & value) const;
  at::Tensor masked_fill(const at::Tensor & mask, const at::Scalar & value) const;
  at::Tensor & masked_fill_(const at::Tensor & mask, const at::Tensor & value) const;
  at::Tensor masked_fill(const at::Tensor & mask, const at::Tensor & value) const;
  at::Tensor & masked_scatter_(const at::Tensor & mask, const at::Tensor & source) const;
  at::Tensor masked_scatter(const at::Tensor & mask, const at::Tensor & source) const;
  at::Tensor view(at::IntArrayRef size) const;
  at::Tensor view(at::ScalarType dtype) const;
  at::Tensor & put_(const at::Tensor & index, const at::Tensor & source, bool accumulate=false) const;
  at::Tensor put(const at::Tensor & index, const at::Tensor & source, bool accumulate=false) const;
  at::Tensor & index_add_(int64_t dim, const at::Tensor & index, const at::Tensor & source) const;
  at::Tensor & index_add_(int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) const;
  at::Tensor index_add(int64_t dim, const at::Tensor & index, const at::Tensor & source) const;
  at::Tensor index_add(int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) const;
  at::Tensor index_add(at::Dimname dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha=1) const;
  at::Tensor & index_fill_(int64_t dim, const at::Tensor & index, const at::Scalar & value) const;
  at::Tensor index_fill(int64_t dim, const at::Tensor & index, const at::Scalar & value) const;
  at::Tensor & index_fill_(int64_t dim, const at::Tensor & index, const at::Tensor & value) const;
  at::Tensor index_fill(int64_t dim, const at::Tensor & index, const at::Tensor & value) const;
  at::Tensor & index_fill_(at::Dimname dim, const at::Tensor & index, const at::Scalar & value) const;
  at::Tensor & index_fill_(at::Dimname dim, const at::Tensor & index, const at::Tensor & value) const;
  at::Tensor index_fill(at::Dimname dim, const at::Tensor & index, const at::Scalar & value) const;
  at::Tensor index_fill(at::Dimname dim, const at::Tensor & index, const at::Tensor & value) const;
  at::Tensor & scatter_(int64_t dim, const at::Tensor & index, const at::Tensor & src) const;
  at::Tensor scatter(int64_t dim, const at::Tensor & index, const at::Tensor & src) const;
  at::Tensor & scatter_(int64_t dim, const at::Tensor & index, const at::Scalar & value) const;
  at::Tensor scatter(int64_t dim, const at::Tensor & index, const at::Scalar & value) const;
  at::Tensor scatter(at::Dimname dim, const at::Tensor & index, const at::Tensor & src) const;
  at::Tensor scatter(at::Dimname dim, const at::Tensor & index, const at::Scalar & value) const;
  at::Tensor & scatter_(int64_t dim, const at::Tensor & index, const at::Tensor & src, std::string reduce) const;
  at::Tensor & scatter_(int64_t dim, const at::Tensor & index, const at::Scalar & value, std::string reduce) const;
  at::Tensor & scatter_add_(int64_t dim, const at::Tensor & index, const at::Tensor & src) const;
  at::Tensor scatter_add(int64_t dim, const at::Tensor & index, const at::Tensor & src) const;
  at::Tensor scatter_add(at::Dimname dim, const at::Tensor & index, const at::Tensor & src) const;
  at::Tensor & eq_(const at::Scalar & other) const;
  at::Tensor & eq_(const at::Tensor & other) const;
  at::Tensor bitwise_and(const at::Scalar & other) const;
  at::Tensor bitwise_and(const at::Tensor & other) const;
  at::Tensor & bitwise_and_(const at::Scalar & other) const;
  at::Tensor & bitwise_and_(const at::Tensor & other) const;
  at::Tensor __and__(const at::Scalar & other) const;
  at::Tensor __and__(const at::Tensor & other) const;
  at::Tensor & __iand__(const at::Scalar & other) const;
  at::Tensor & __iand__(const at::Tensor & other) const;
  at::Tensor bitwise_or(const at::Scalar & other) const;
  at::Tensor bitwise_or(const at::Tensor & other) const;
  at::Tensor & bitwise_or_(const at::Scalar & other) const;
  at::Tensor & bitwise_or_(const at::Tensor & other) const;
  at::Tensor __or__(const at::Scalar & other) const;
  at::Tensor __or__(const at::Tensor & other) const;
  at::Tensor & __ior__(const at::Scalar & other) const;
  at::Tensor & __ior__(const at::Tensor & other) const;
  at::Tensor bitwise_xor(const at::Scalar & other) const;
  at::Tensor bitwise_xor(const at::Tensor & other) const;
  at::Tensor & bitwise_xor_(const at::Scalar & other) const;
  at::Tensor & bitwise_xor_(const at::Tensor & other) const;
  at::Tensor __xor__(const at::Scalar & other) const;
  at::Tensor __xor__(const at::Tensor & other) const;
  at::Tensor & __ixor__(const at::Scalar & other) const;
  at::Tensor & __ixor__(const at::Tensor & other) const;
  at::Tensor __lshift__(const at::Scalar & other) const;
  at::Tensor __lshift__(const at::Tensor & other) const;
  at::Tensor & __ilshift__(const at::Scalar & other) const;
  at::Tensor & __ilshift__(const at::Tensor & other) const;
  at::Tensor __rshift__(const at::Scalar & other) const;
  at::Tensor __rshift__(const at::Tensor & other) const;
  at::Tensor & __irshift__(const at::Scalar & other) const;
  at::Tensor & __irshift__(const at::Tensor & other) const;
  at::Tensor & tril_(int64_t diagonal=0) const;
  at::Tensor & triu_(int64_t diagonal=0) const;
  at::Tensor & digamma_() const;
  at::Tensor & renorm_(const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) const;
  at::Tensor & lerp_(const at::Tensor & end, const at::Scalar & weight) const;
  at::Tensor & lerp_(const at::Tensor & end, const at::Tensor & weight) const;
  at::Tensor & fmod_(const at::Scalar & other) const;
  at::Tensor & fmod_(const at::Tensor & other) const;
  at::Tensor & remainder_(const at::Scalar & other) const;
  at::Tensor & remainder_(const at::Tensor & other) const;
  at::Tensor & addbmm_(const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor addbmm(const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta=1, const at::Scalar & alpha=1) const;
  at::Tensor & addcdiv_(const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value=1) const;
  at::Tensor & random_(int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & random_(int64_t to, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & random_(c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & uniform_(double from=0, double to=1, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & cauchy_(double median=0, double sigma=1, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & log_normal_(double mean=1, double std=2, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & exponential_(double lambd=1, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & geometric_(double p, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor diag(int64_t diagonal=0) const;
  at::Tensor cross(const at::Tensor & other, c10::optional<int64_t> dim=c10::nullopt) const;
  at::Tensor triu(int64_t diagonal=0) const;
  at::Tensor tril(int64_t diagonal=0) const;
  at::Tensor trace() const;
  at::Tensor ne(const at::Scalar & other) const;
  at::Tensor ne(const at::Tensor & other) const;
  at::Tensor & ne_(const at::Scalar & other) const;
  at::Tensor & ne_(const at::Tensor & other) const;
  at::Tensor not_equal(const at::Scalar & other) const;
  at::Tensor not_equal(const at::Tensor & other) const;
  at::Tensor & not_equal_(const at::Scalar & other) const;
  at::Tensor & not_equal_(const at::Tensor & other) const;
  at::Tensor eq(const at::Scalar & other) const;
  at::Tensor eq(const at::Tensor & other) const;
  at::Tensor ge(const at::Scalar & other) const;
  at::Tensor ge(const at::Tensor & other) const;
  at::Tensor & ge_(const at::Scalar & other) const;
  at::Tensor & ge_(const at::Tensor & other) const;
  at::Tensor greater_equal(const at::Scalar & other) const;
  at::Tensor greater_equal(const at::Tensor & other) const;
  at::Tensor & greater_equal_(const at::Scalar & other) const;
  at::Tensor & greater_equal_(const at::Tensor & other) const;
  at::Tensor le(const at::Scalar & other) const;
  at::Tensor le(const at::Tensor & other) const;
  at::Tensor & le_(const at::Scalar & other) const;
  at::Tensor & le_(const at::Tensor & other) const;
  at::Tensor less_equal(const at::Scalar & other) const;
  at::Tensor less_equal(const at::Tensor & other) const;
  at::Tensor & less_equal_(const at::Scalar & other) const;
  at::Tensor & less_equal_(const at::Tensor & other) const;
  at::Tensor gt(const at::Scalar & other) const;
  at::Tensor gt(const at::Tensor & other) const;
  at::Tensor & gt_(const at::Scalar & other) const;
  at::Tensor & gt_(const at::Tensor & other) const;
  at::Tensor greater(const at::Scalar & other) const;
  at::Tensor greater(const at::Tensor & other) const;
  at::Tensor & greater_(const at::Scalar & other) const;
  at::Tensor & greater_(const at::Tensor & other) const;
  at::Tensor lt(const at::Scalar & other) const;
  at::Tensor lt(const at::Tensor & other) const;
  at::Tensor & lt_(const at::Scalar & other) const;
  at::Tensor & lt_(const at::Tensor & other) const;
  at::Tensor less(const at::Scalar & other) const;
  at::Tensor less(const at::Tensor & other) const;
  at::Tensor & less_(const at::Scalar & other) const;
  at::Tensor & less_(const at::Tensor & other) const;
  at::Tensor take(const at::Tensor & index) const;
  at::Tensor take_along_dim(const at::Tensor & indices, c10::optional<int64_t> dim=c10::nullopt) const;
  at::Tensor index_select(int64_t dim, const at::Tensor & index) const;
  at::Tensor index_select(at::Dimname dim, const at::Tensor & index) const;
  at::Tensor masked_select(const at::Tensor & mask) const;
  at::Tensor nonzero() const;
  std::vector<at::Tensor> nonzero_numpy() const;
  at::Tensor gather(int64_t dim, const at::Tensor & index, bool sparse_grad=false) const;
  at::Tensor gather(at::Dimname dim, const at::Tensor & index, bool sparse_grad=false) const;
  at::Tensor addcmul(const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value=1) const;
  at::Tensor & addcmul_(const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value=1) const;
  at::Tensor addcdiv(const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value=1) const;
  std::tuple<at::Tensor,at::Tensor> lstsq(const at::Tensor & A) const;
  std::tuple<at::Tensor,at::Tensor> triangular_solve(const at::Tensor & A, bool upper=true, bool transpose=false, bool unitriangular=false) const;
  std::tuple<at::Tensor,at::Tensor> symeig(bool eigenvectors=false, bool upper=true) const;
  std::tuple<at::Tensor,at::Tensor> eig(bool eigenvectors=false) const;
  std::tuple<at::Tensor,at::Tensor,at::Tensor> svd(bool some=true, bool compute_uv=true) const;
  at::Tensor swapaxes(int64_t axis0, int64_t axis1) const;
  at::Tensor & swapaxes_(int64_t axis0, int64_t axis1) const;
  at::Tensor swapdims(int64_t dim0, int64_t dim1) const;
  at::Tensor & swapdims_(int64_t dim0, int64_t dim1) const;
  at::Tensor cholesky(bool upper=false) const;
  at::Tensor cholesky_solve(const at::Tensor & input2, bool upper=false) const;
  std::tuple<at::Tensor,at::Tensor> solve(const at::Tensor & A) const;
  at::Tensor cholesky_inverse(bool upper=false) const;
  std::tuple<at::Tensor,at::Tensor> qr(bool some=true) const;
  std::tuple<at::Tensor,at::Tensor> geqrf() const;
  at::Tensor orgqr(const at::Tensor & input2) const;
  at::Tensor ormqr(const at::Tensor & input2, const at::Tensor & input3, bool left=true, bool transpose=false) const;
  at::Tensor lu_solve(const at::Tensor & LU_data, const at::Tensor & LU_pivots) const;
  at::Tensor multinomial(int64_t num_samples, bool replacement=false, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor & lgamma_() const;
  at::Tensor lgamma() const;
  at::Tensor digamma() const;
  at::Tensor polygamma(int64_t n) const;
  at::Tensor & polygamma_(int64_t n) const;
  at::Tensor erfinv() const;
  at::Tensor & erfinv_() const;
  at::Tensor i0() const;
  at::Tensor & i0_() const;
  at::Tensor sign() const;
  at::Tensor & sign_() const;
  at::Tensor signbit() const;
  at::Tensor dist(const at::Tensor & other, const at::Scalar & p=2) const;
  at::Tensor & atan2_(const at::Tensor & other) const;
  at::Tensor atan2(const at::Tensor & other) const;
  at::Tensor lerp(const at::Tensor & end, const at::Scalar & weight) const;
  at::Tensor lerp(const at::Tensor & end, const at::Tensor & weight) const;
  at::Tensor histc(int64_t bins=100, const at::Scalar & min=0, const at::Scalar & max=0) const;
  at::Tensor fmod(const at::Scalar & other) const;
  at::Tensor fmod(const at::Tensor & other) const;
  at::Tensor hypot(const at::Tensor & other) const;
  at::Tensor & hypot_(const at::Tensor & other) const;
  at::Tensor igamma(const at::Tensor & other) const;
  at::Tensor & igamma_(const at::Tensor & other) const;
  at::Tensor igammac(const at::Tensor & other) const;
  at::Tensor & igammac_(const at::Tensor & other) const;
  at::Tensor nextafter(const at::Tensor & other) const;
  at::Tensor & nextafter_(const at::Tensor & other) const;
  at::Tensor remainder(const at::Scalar & other) const;
  at::Tensor remainder(const at::Tensor & other) const;
  at::Tensor min() const;
  at::Tensor fmin(const at::Tensor & other) const;
  at::Tensor max() const;
  at::Tensor fmax(const at::Tensor & other) const;
  at::Tensor maximum(const at::Tensor & other) const;
  at::Tensor max(const at::Tensor & other) const;
  at::Tensor minimum(const at::Tensor & other) const;
  at::Tensor min(const at::Tensor & other) const;
  at::Tensor quantile(double q, c10::optional<int64_t> dim=c10::nullopt, bool keepdim=false) const;
  at::Tensor quantile(const at::Tensor & q, c10::optional<int64_t> dim=c10::nullopt, bool keepdim=false) const;
  at::Tensor nanquantile(double q, c10::optional<int64_t> dim=c10::nullopt, bool keepdim=false) const;
  at::Tensor nanquantile(const at::Tensor & q, c10::optional<int64_t> dim=c10::nullopt, bool keepdim=false) const;
  at::Tensor quantile(double q, c10::optional<int64_t> dim, bool keepdim, std::string interpolation) const;
  at::Tensor quantile(const at::Tensor & q, c10::optional<int64_t> dim, bool keepdim, std::string interpolation) const;
  at::Tensor nanquantile(double q, c10::optional<int64_t> dim, bool keepdim, std::string interpolation) const;
  at::Tensor nanquantile(const at::Tensor & q, c10::optional<int64_t> dim, bool keepdim, std::string interpolation) const;
  std::tuple<at::Tensor,at::Tensor> sort(int64_t dim=-1, bool descending=false) const;
  std::tuple<at::Tensor,at::Tensor> sort(c10::optional<bool> stable, int64_t dim=-1, bool descending=false) const;
  std::tuple<at::Tensor,at::Tensor> sort(at::Dimname dim, bool descending=false) const;
  std::tuple<at::Tensor,at::Tensor> sort(c10::optional<bool> stable, at::Dimname dim, bool descending=false) const;
  at::Tensor msort() const;
  at::Tensor argsort(int64_t dim=-1, bool descending=false) const;
  at::Tensor argsort(at::Dimname dim, bool descending=false) const;
  std::tuple<at::Tensor,at::Tensor> topk(int64_t k, int64_t dim=-1, bool largest=true, bool sorted=true) const;
  at::Tensor all() const;
  at::Tensor any() const;
  at::Tensor renorm(const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) const;
  at::Tensor unfold(int64_t dimension, int64_t size, int64_t step) const;
  bool equal(const at::Tensor & other) const;
  at::Tensor pow(const at::Tensor & exponent) const;
  at::Tensor pow(const at::Scalar & exponent) const;
  at::Tensor & pow_(const at::Scalar & exponent) const;
  at::Tensor & pow_(const at::Tensor & exponent) const;
  at::Tensor float_power(const at::Tensor & exponent) const;
  at::Tensor float_power(const at::Scalar & exponent) const;
  at::Tensor & float_power_(const at::Scalar & exponent) const;
  at::Tensor & float_power_(const at::Tensor & exponent) const;
  at::Tensor & normal_(double mean=0, double std=1, c10::optional<at::Generator> generator=c10::nullopt) const;
  at::Tensor alias() const;
  at::Tensor isfinite() const;
  at::Tensor isinf() const;
  void record_stream(at::Stream s) const;
  at::Tensor isposinf() const;
  at::Tensor isneginf() const;
  at::Tensor det() const;
  at::Tensor inner(const at::Tensor & other) const;
  at::Tensor outer(const at::Tensor & vec2) const;
  at::Tensor ger(const at::Tensor & vec2) const;

  // Special C++ only overloads for std()-like functions (See gh-40287)
  // These are needed because int -> bool conversion takes precedence over int -> IntArrayRef
  // So, for example std(0) would select the std(unbiased=False) overload

  Tensor var(int dim) const {
    return var(IntArrayRef{dim});
  }

  Tensor std(int dim) const {
    return std(IntArrayRef{dim});
  }

  // We changed .dtype() to return a TypeMeta in #12766. Ideally, we want the
  // at::kDouble and its friends to be TypeMeta's, but that hasn't happened yet.
  // Before that change, we make this method to maintain BC for C++ usage like
  // `x.to(y.dtype)`.
  // TODO: remove following two after at::kDouble and its friends are TypeMeta's.
  inline Tensor to(caffe2::TypeMeta type_meta, bool non_blocking=false, bool copy=false) const {
    return this->to(/*scalar_type=*/typeMetaToScalarType(type_meta), non_blocking, copy);
  }
  inline Tensor to(Device device, caffe2::TypeMeta type_meta, bool non_blocking=false, bool copy=false) const {
    return this->to(device, /*scalar_type=*/typeMetaToScalarType(type_meta), non_blocking, copy);
  }

  template <typename F, typename... Args>
  decltype(auto) m(F func, Args&&... params) const {
    return func(*this, std::forward<Args>(params)...);
  }

  /// NOTE: This is similar to the legacy `.data()` function on `Variable`, and is intended
  /// to be used from functions that need to access the `Variable`'s equivalent `Tensor`
  /// (i.e. `Tensor` that shares the same storage and tensor metadata with the `Variable`).
  ///
  /// One notable difference with the legacy `.data()` function is that changes to the
  /// returned `Tensor`'s tensor metadata (e.g. sizes / strides / storage / storage_offset)
  /// will not update the original `Variable`, due to the fact that this function
  /// shallow-copies the `Variable`'s underlying TensorImpl.
  at::Tensor tensor_data() const;

  /// NOTE: `var.variable_data()` in C++ has the same semantics as `tensor.data`
  /// in Python, which create a new `Variable` that shares the same storage and
  /// tensor metadata with the original `Variable`, but with a completely new
  /// autograd history.
  ///
  /// NOTE: If we change the tensor metadata (e.g. sizes / strides /
  /// storage / storage_offset) of a variable created from `var.variable_data()`, those
  /// changes will not update the original variable `var`. In `.variable_data()`, we set
  /// `allow_tensor_metadata_change_` to false to make such changes explicitly illegal,
  /// in order to prevent users from changing metadata of `var.variable_data()`
  /// and expecting the original variable `var` to also be updated.
  at::Tensor variable_data() const;

  // Gradient Node and Edges
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  /// Gets the gradient function of the `Variable`. If this is a leaf variable,
  /// the pointer returned will be null.
  ///
  /// For View Variables:
  /// Gets the up-to-date grad_fn. If the shared data or base was modified, we
  /// re-create the grad_fn to express the up-to-date view relationship between
  /// this and the base Variable.
  const std::shared_ptr<torch::autograd::Node>& grad_fn() const;

  // Hooks
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  template <typename T>
  using hook_return_void_t = std::enable_if_t<std::is_void<typename std::result_of<T&(Tensor)>::type>::value, unsigned>;
  template <typename T>
  using hook_return_var_t = std::enable_if_t<std::is_same<typename std::result_of<T&(Tensor)>::type, Tensor>::value, unsigned>;

  /// Registers a backward hook.
  ///
  /// The hook will be called every time a gradient with respect to the Tensor is computed.
  /// The hook should have one of the following signature:
  /// ```
  /// hook(Tensor grad) -> Tensor
  /// ```
  /// ```
  /// hook(Tensor grad) -> void
  /// ```
  /// The hook should not modify its argument, but it can optionally return a new gradient
  /// which will be used in place of `grad`.
  ///
  /// This function returns the index of the hook in the list which can be used to remove hook.
  ///
  /// Example:
  /// @code
  /// auto v = torch::tensor({0., 0., 0.}, torch::requires_grad());
  /// auto h = v.register_hook([](torch::Tensor grad){ return grad * 2; }); // double the gradient
  /// v.backward(torch::tensor({1., 2., 3.}));
  /// // This prints:
  /// // ```
  /// //  2
  /// //  4
  /// //  6
  /// // [ CPUFloatType{3} ]
  /// // ```
  /// std::cout << v.grad() << std::endl;
  /// v.remove_hook(h);  // removes the hook
  /// @endcode
  template <typename T>
  hook_return_void_t<T> register_hook(T&& hook) const;
  template <typename T>
  hook_return_var_t<T> register_hook(T&& hook) const;

private:
  unsigned _register_hook(std::function<Tensor(const Tensor&)> hook) const;

public:

  /// Remove hook at given position
  void remove_hook(unsigned pos) const;

  // Variable methods
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  bool is_leaf() const;

  int64_t output_nr() const;

  void set_data(const Tensor & new_data) const;

  Tensor data() const;

  int64_t _version() const;

  void retain_grad() const;

  void _backward(TensorList inputs, const c10::optional<Tensor>& gradient, c10::optional<bool> keep_graph, bool create_graph) const;

  const Tensor& requires_grad_(bool _requires_grad=true) const;

  // View Variables
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  /// Returns true if this `Variable` is a view of another `Variable`.
  bool is_view() const;

  /// Returns the `Variable` that this `Variable` is a view of. If this
  /// `Variable` is not a view, throw a `std::runtime_error`.
  const Tensor& _base() const;

  // Miscellaneous
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  const std::string& name() const;

protected:
  friend class ::caffe2::Tensor;

  void enforce_invariants();
  c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl> impl_;
};

// For "multiple ... operators specified" warnings, closing brace of class
// declaration must be included between pragma push & pop
#ifdef _MSC_VER
#pragma warning( pop )
#endif

inline int64_t get_device(const Tensor& self) {
  return self.get_device();
}

template <typename T>
auto Tensor::register_hook(T&& hook) const -> Tensor::hook_return_void_t<T> {
  // Return the grad argument in case of a hook with void return type to have an
  // std::function with Tensor return type
  static_assert(std::is_same<decltype(hook(Tensor())), void>::value,
                "Expected hook to return void");
  return _register_hook([fn=std::forward<T>(hook)](const Tensor& grad) {
    fn(grad);
    return Tensor();
  });
}

template <typename T>
auto Tensor::register_hook(T&& hook) const -> Tensor::hook_return_var_t<T> {
  return _register_hook(std::forward<T>(hook));
}

namespace detail {
// Helper creator for Tensor class which doesn't requires the users to pass
// in an intrusive_ptr instead it just converts the argument passed to
// requested intrusive_ptr type.
template <typename T, typename... Args>
Tensor make_tensor(Args&&... args) {
  return Tensor(c10::make_intrusive<T>(std::forward<Args>(args)...));
}

} // namespace detail

static inline DispatchKey legacyExtractDispatchKey(const Tensor& t) {
  return legacyExtractDispatchKey(t.key_set());
}

} // namespace at

namespace c10 {
template <>
struct MaybeOwnedTraits<at::Tensor> {
  using owned_type = at::Tensor;
  using borrow_type = at::Tensor;

  static borrow_type createBorrow(const owned_type& from) {
    // NOTE: this can be implemented without the special
    // unsafe_borrow_t Tensor constructor as
    //
    // return borrow_type(c10::intrusive_ptr<at::TensorImpl, at::UndefinedTensorImpl>::reclaim(from.unsafeGetTensorImpl()));
    //
    // but that hurts inlining due to the nullptr check in the
    // Tensor(c10::intrusive_ptr<...>) constructor. We already know
    // that from.impl_ isn't null because from is a valid Tensor, so
    // we needn't do the check again. (using __builtin_assume can
    // avoid this, but wouldn't be portable to MSVC.)
    return borrow_type(borrow_type::unsafe_borrow_t{}, from);
  }

  static void assignBorrow(borrow_type& lhs, const borrow_type& rhs) {
    lhs.unsafeReleaseTensorImpl();
    // See above note: this can be implemented with public API
    // similarly to createBorrow(), but that would hurt inlining.
    lhs = borrow_type(borrow_type::unsafe_borrow_t{}, rhs);
  }

  static void destroyBorrow(borrow_type& toDestroy) {
    toDestroy.unsafeReleaseTensorImpl(); // "leak" it, but it was already +0.
  }

  static const owned_type& referenceFromBorrow(const borrow_type& borrow) {
    return borrow;
  }

  static const owned_type* pointerFromBorrow(const borrow_type& borrow) {
    return &borrow;
  }

  static bool debugBorrowIsValid(const borrow_type& borrow) {
    return true;
  }
};
} // namespace c10

namespace at {

inline c10::MaybeOwned<Tensor> borrow_from_optional_tensor(
    const c10::optional<Tensor>& opt) {
  return opt.has_value()
    ? c10::MaybeOwned<Tensor>::borrowed(*opt)
    : c10::MaybeOwned<Tensor>::owned(c10::in_place);
}

inline c10::MaybeOwned<Tensor> Tensor::expect_contiguous(MemoryFormat memory_format) const & {
  if (is_contiguous(memory_format)) {
    return c10::MaybeOwned<Tensor>::borrowed(*this);
  } else {
    return c10::MaybeOwned<Tensor>::owned(__dispatch_contiguous(memory_format));
  }
}
} // namespace at
